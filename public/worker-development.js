/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (function() { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./worker/index.js":
/*!*************************!*\
  !*** ./worker/index.js ***!
  \*************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("const channel = new BroadcastChannel(\"sw-messages\");\nconst CACHE_NAME = \"notification-icons-v1\";\nconst ICONS_TO_CACHE = [\n    \"/assets/icons/call.png\",\n    \"/assets/icons/callr.png\"\n];\nself.addEventListener(\"install\", (event)=>{\n    event.waitUntil(caches.open(CACHE_NAME).then((cache)=>cache.addAll(ICONS_TO_CACHE)));\n});\nself.addEventListener(\"fetch\", (event)=>{\n    if (ICONS_TO_CACHE.includes(event.request.url)) {\n        event.respondWith(caches.match(event.request).then((response)=>response || fetch(event.request)));\n    }\n});\nself.addEventListener(\"notificationclose\", function(event) {\n    event.stopImmediatePropagation();\n    const notification = event.notification;\n    const data = notification.data;\n    console.log(\"notification close\", data);\n    if (data && data.type === \"call\") {\n        // Отправляем сообщение через BroadcastChannel\n        channel.postMessage({\n            type: \"CALL_ENDED\",\n            action: \"reject\",\n            chatId: data.chatId\n        });\n        // Отправляем сообщение всем активным клиентам\n        self.clients.matchAll().then((clients1)=>{\n            clients1.forEach((client)=>{\n                client.postMessage({\n                    type: \"CALL_ENDED\",\n                    action: \"reject\",\n                    chatId: data.chatId\n                });\n            });\n        });\n        // Сохраняем информацию о закрытии вызова в кэше\n        caches.open(\"call-status\").then((cache)=>{\n            cache.put(\"last-call-status\", new Response(JSON.stringify({\n                status: \"closed\",\n                chatId: data.chatId,\n                timestamp: Date.now()\n            })));\n        });\n    }\n});\nself.addEventListener(\"push\", function(event) {\n    event.preventDefault();\n    let data = {};\n    if (event.data) {\n        data = event.data.json();\n    }\n    if (data.chatId) {\n        const chatDataResponse = new Response(new Blob([\n            JSON.stringify(data)\n        ], {\n            type: \"application/json\"\n        }));\n        event.waitUntil(caches.open(\"chat-data\").then((cache)=>cache.put(\"current-chat-data\", chatDataResponse)));\n    }\n    event.waitUntil(self.clients.matchAll({\n        type: \"window\",\n        includeUncontrolled: true\n    }).then(function(clients1) {\n        let isChatOpen = false;\n        const chatUrl = \"\".concat(\"http://localhost:3000\", \"/chat/\").concat(data.chatId);\n        for (let client of clients1){\n            if (client.url.includes(chatUrl) && \"focus\" in client && data.type !== \"call\") {\n                isChatOpen = true;\n                client.focus();\n                break;\n            }\n        }\n        const title = data.title || \"Message from Next Post\";\n        const userIcon = data.userIcon;\n        const type = data.type || \"message\";\n        const notificationTag = \"chat-\".concat(data.chatId, \"-\").concat(data.body);\n        const options = {\n            body: data.body || \"Click to open chat\",\n            icon: userIcon,\n            badge: \"/assets/email.png\",\n            sound: \"/assets/notif.mp3\",\n            vibrate: [\n                500,\n                110,\n                500,\n                110,\n                450,\n                110,\n                200,\n                110,\n                170,\n                40,\n                450,\n                110,\n                200,\n                110,\n                170,\n                40,\n                500\n            ],\n            tag: notificationTag,\n            renotify: false\n        };\n        if (type === \"call\") {\n            options.actions = [\n                {\n                    action: \"accept\",\n                    type: \"button\",\n                    title: \"Accept Call\",\n                    icon: \"/assets/icons/callr.png\"\n                },\n                {\n                    action: \"reject\",\n                    type: \"button\",\n                    title: \"Reject Call\",\n                    icon: \"/assets/icons/call.png\"\n                }\n            ];\n            // Отправляем сообщение через BroadcastChannel\n            channel.postMessage({\n                type: \"INCOMING_CALL\",\n                chatId: data.chatId\n            });\n            return self.registration.showNotification(title, options);\n        } else if (!isChatOpen) {\n            return self.registration.getNotifications({\n                tag: notificationTag\n            }).then((existingNotifications)=>{\n                if (existingNotifications.length === 0) {\n                    return self.registration.showNotification(title, options);\n                }\n            });\n        }\n    }));\n});\nself.addEventListener(\"notificationclick\", function(event) {\n    event.preventDefault();\n    event.notification.close();\n    event.waitUntil(caches.open(\"chat-data\").then((cache)=>cache.match(\"current-chat-data\")).then((response)=>{\n        if (response) {\n            return response.json().then((data)=>{\n                const { chatId, type } = data;\n                self.clients.matchAll({\n                    type: \"window\",\n                    includeUncontrolled: true\n                }).then(function(clients1) {\n                    let client = clients1.find((c)=>c.url.startsWith(\"http://localhost:3000\") && \"navigate\" in c);\n                    if (type === \"call\") {\n                        let chatUrl = \"\".concat(\"http://localhost:3000\", \"/chat/\").concat(chatId, \"?source=push\");\n                        if (event.action === \"reject\" || event.action === \"accept\") {\n                            chatUrl += \"&type=\".concat(event.action);\n                            // Отправляем сообщение через BroadcastChannel\n                            channel.postMessage({\n                                type: \"CALL_ENDED\",\n                                action: event.action,\n                                chatId: chatId\n                            });\n                        }\n                        if (event.action === \"reject\") {\n                            return;\n                        }\n                        if (client) {\n                            return client.navigate(chatUrl).then((client)=>client.focus());\n                        } else {\n                            return clients1.openWindow(chatUrl);\n                        }\n                    } else {\n                        const chatUrl = chatId ? \"\".concat(\"http://localhost:3000\", \"/chat/\").concat(chatId) : \"\".concat(\"http://localhost:3000\", \"/chat\");\n                        return clients1.openWindow(chatUrl);\n                    }\n                });\n            });\n        } else {\n            caches.delete(\"action-data\");\n            caches.delete(\"chat-data\");\n            return clients.openWindow(\"\".concat(\"http://localhost:3000\", \"/chat\"));\n        }\n    }));\n});\n// Добавляем обработчик сообщений от основного потока (если понадобится)\nself.addEventListener(\"message\", (event)=>{\n    console.log(\"SW received message:\", event.data);\n// Здесь можно обрабатывать сообщения от основного потока, если это необходимо\n});\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                /* unsupported import.meta.webpackHot */ undefined.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUVBLElBQUl0QixNQUFNcUIsTUFBTSxLQUFLLFVBQVU7NEJBQzdCO3dCQUNGO3dCQUVBLElBQUlLLFFBQVE7NEJBQ1YsT0FBT0EsT0FDSnlDLFFBQVEsQ0FBQzFCLFNBQ1RyQyxJQUFJLENBQUMsQ0FBQ3NCLFNBQVdBLE9BQU9tQixLQUFLO3dCQUNsQyxPQUFPOzRCQUNMLE9BQU90QixTQUFRNkMsVUFBVSxDQUFDM0I7d0JBQzVCO29CQUNGLE9BQU87d0JBQ0wsTUFBTUEsVUFBVW5CLFNBQ1osR0FBNENBLE9BQXpDb0IsdUJBQWdDLEVBQUMsVUFBZSxPQUFQcEIsVUFDNUMsR0FBb0MsT0FBakNvQix1QkFBZ0MsRUFBQzt3QkFDeEMsT0FBT25CLFNBQVE2QyxVQUFVLENBQUMzQjtvQkFDNUI7Z0JBQ0Y7WUFDSjtRQUNGLE9BQU87WUFDTHZDLE9BQU9tRSxNQUFNLENBQUM7WUFDZG5FLE9BQU9tRSxNQUFNLENBQUM7WUFDZCxPQUFPOUMsUUFBUTZDLFVBQVUsQ0FBQyxHQUFvQyxPQUFqQzFCLHVCQUFnQyxFQUFDO1FBQ2hFO0lBQ0Y7QUFFTjtBQUVBLHdFQUF3RTtBQUN4RTVDLEtBQUtDLGdCQUFnQixDQUFDLFdBQVcsQ0FBQ0M7SUFDaENpQixRQUFRQyxHQUFHLENBQUMsd0JBQXdCbEIsTUFBTWdCLElBQUk7QUFDOUMsOEVBQThFO0FBQ2hGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3dvcmtlci9pbmRleC5qcz84MDVlIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IGNoYW5uZWwgPSBuZXcgQnJvYWRjYXN0Q2hhbm5lbChcInN3LW1lc3NhZ2VzXCIpO1xyXG5jb25zdCBDQUNIRV9OQU1FID0gXCJub3RpZmljYXRpb24taWNvbnMtdjFcIjtcclxuY29uc3QgSUNPTlNfVE9fQ0FDSEUgPSBbXCIvYXNzZXRzL2ljb25zL2NhbGwucG5nXCIsIFwiL2Fzc2V0cy9pY29ucy9jYWxsci5wbmdcIl07XHJcblxyXG5zZWxmLmFkZEV2ZW50TGlzdGVuZXIoXCJpbnN0YWxsXCIsIChldmVudCkgPT4ge1xyXG4gIGV2ZW50LndhaXRVbnRpbChcclxuICAgIGNhY2hlcy5vcGVuKENBQ0hFX05BTUUpLnRoZW4oKGNhY2hlKSA9PiBjYWNoZS5hZGRBbGwoSUNPTlNfVE9fQ0FDSEUpKVxyXG4gICk7XHJcbn0pO1xyXG5cclxuc2VsZi5hZGRFdmVudExpc3RlbmVyKFwiZmV0Y2hcIiwgKGV2ZW50KSA9PiB7XHJcbiAgaWYgKElDT05TX1RPX0NBQ0hFLmluY2x1ZGVzKGV2ZW50LnJlcXVlc3QudXJsKSkge1xyXG4gICAgZXZlbnQucmVzcG9uZFdpdGgoXHJcbiAgICAgIGNhY2hlc1xyXG4gICAgICAgIC5tYXRjaChldmVudC5yZXF1ZXN0KVxyXG4gICAgICAgIC50aGVuKChyZXNwb25zZSkgPT4gcmVzcG9uc2UgfHwgZmV0Y2goZXZlbnQucmVxdWVzdCkpXHJcbiAgICApO1xyXG4gIH1cclxufSk7XHJcblxyXG5zZWxmLmFkZEV2ZW50TGlzdGVuZXIoXCJub3RpZmljYXRpb25jbG9zZVwiLCBmdW5jdGlvbiAoZXZlbnQpIHtcclxuICBldmVudC5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcclxuICBjb25zdCBub3RpZmljYXRpb24gPSBldmVudC5ub3RpZmljYXRpb247XHJcbiAgY29uc3QgZGF0YSA9IG5vdGlmaWNhdGlvbi5kYXRhO1xyXG4gIGNvbnNvbGUubG9nKFwibm90aWZpY2F0aW9uIGNsb3NlXCIsIGRhdGEpO1xyXG5cclxuICBpZiAoZGF0YSAmJiBkYXRhLnR5cGUgPT09IFwiY2FsbFwiKSB7XHJcbiAgICAvLyDQntGC0L/RgNCw0LLQu9GP0LXQvCDRgdC+0L7QsdGJ0LXQvdC40LUg0YfQtdGA0LXQtyBCcm9hZGNhc3RDaGFubmVsXHJcbiAgICBjaGFubmVsLnBvc3RNZXNzYWdlKHtcclxuICAgICAgdHlwZTogXCJDQUxMX0VOREVEXCIsXHJcbiAgICAgIGFjdGlvbjogXCJyZWplY3RcIixcclxuICAgICAgY2hhdElkOiBkYXRhLmNoYXRJZCxcclxuICAgIH0pO1xyXG4gICAgLy8g0J7RgtC/0YDQsNCy0LvRj9C10Lwg0YHQvtC+0LHRidC10L3QuNC1INCy0YHQtdC8INCw0LrRgtC40LLQvdGL0Lwg0LrQu9C40LXQvdGC0LDQvFxyXG4gICAgc2VsZi5jbGllbnRzLm1hdGNoQWxsKCkudGhlbigoY2xpZW50cykgPT4ge1xyXG4gICAgICBjbGllbnRzLmZvckVhY2goKGNsaWVudCkgPT4ge1xyXG4gICAgICAgIGNsaWVudC5wb3N0TWVzc2FnZSh7XHJcbiAgICAgICAgICB0eXBlOiBcIkNBTExfRU5ERURcIixcclxuICAgICAgICAgIGFjdGlvbjogXCJyZWplY3RcIixcclxuICAgICAgICAgIGNoYXRJZDogZGF0YS5jaGF0SWQsXHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH0pO1xyXG4gICAgfSk7XHJcblxyXG4gICAgLy8g0KHQvtGF0YDQsNC90Y/QtdC8INC40L3RhNC+0YDQvNCw0YbQuNGOINC+INC30LDQutGA0YvRgtC40Lgg0LLRi9C30L7QstCwINCyINC60Y3RiNC1XHJcbiAgICBjYWNoZXMub3BlbihcImNhbGwtc3RhdHVzXCIpLnRoZW4oKGNhY2hlKSA9PiB7XHJcbiAgICAgIGNhY2hlLnB1dChcclxuICAgICAgICBcImxhc3QtY2FsbC1zdGF0dXNcIixcclxuICAgICAgICBuZXcgUmVzcG9uc2UoXHJcbiAgICAgICAgICBKU09OLnN0cmluZ2lmeSh7XHJcbiAgICAgICAgICAgIHN0YXR1czogXCJjbG9zZWRcIixcclxuICAgICAgICAgICAgY2hhdElkOiBkYXRhLmNoYXRJZCxcclxuICAgICAgICAgICAgdGltZXN0YW1wOiBEYXRlLm5vdygpLFxyXG4gICAgICAgICAgfSlcclxuICAgICAgICApXHJcbiAgICAgICk7XHJcbiAgICB9KTtcclxuICB9XHJcbn0pO1xyXG5cclxuc2VsZi5hZGRFdmVudExpc3RlbmVyKFwicHVzaFwiLCBmdW5jdGlvbiAoZXZlbnQpIHtcclxuICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gIGxldCBkYXRhID0ge307XHJcbiAgaWYgKGV2ZW50LmRhdGEpIHtcclxuICAgIGRhdGEgPSBldmVudC5kYXRhLmpzb24oKTtcclxuICB9XHJcblxyXG4gIGlmIChkYXRhLmNoYXRJZCkge1xyXG4gICAgY29uc3QgY2hhdERhdGFSZXNwb25zZSA9IG5ldyBSZXNwb25zZShcclxuICAgICAgbmV3IEJsb2IoW0pTT04uc3RyaW5naWZ5KGRhdGEpXSwgeyB0eXBlOiBcImFwcGxpY2F0aW9uL2pzb25cIiB9KVxyXG4gICAgKTtcclxuICAgIGV2ZW50LndhaXRVbnRpbChcclxuICAgICAgY2FjaGVzXHJcbiAgICAgICAgLm9wZW4oXCJjaGF0LWRhdGFcIilcclxuICAgICAgICAudGhlbigoY2FjaGUpID0+IGNhY2hlLnB1dChcImN1cnJlbnQtY2hhdC1kYXRhXCIsIGNoYXREYXRhUmVzcG9uc2UpKVxyXG4gICAgKTtcclxuICB9XHJcblxyXG4gIGV2ZW50LndhaXRVbnRpbChcclxuICAgIHNlbGYuY2xpZW50c1xyXG4gICAgICAubWF0Y2hBbGwoeyB0eXBlOiBcIndpbmRvd1wiLCBpbmNsdWRlVW5jb250cm9sbGVkOiB0cnVlIH0pXHJcbiAgICAgIC50aGVuKGZ1bmN0aW9uIChjbGllbnRzKSB7XHJcbiAgICAgICAgbGV0IGlzQ2hhdE9wZW4gPSBmYWxzZTtcclxuICAgICAgICBjb25zdCBjaGF0VXJsID0gYCR7cHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfQkFTRV9VUkx9L2NoYXQvJHtkYXRhLmNoYXRJZH1gO1xyXG5cclxuICAgICAgICBmb3IgKGxldCBjbGllbnQgb2YgY2xpZW50cykge1xyXG4gICAgICAgICAgaWYgKFxyXG4gICAgICAgICAgICBjbGllbnQudXJsLmluY2x1ZGVzKGNoYXRVcmwpICYmXHJcbiAgICAgICAgICAgIFwiZm9jdXNcIiBpbiBjbGllbnQgJiZcclxuICAgICAgICAgICAgZGF0YS50eXBlICE9PSBcImNhbGxcIlxyXG4gICAgICAgICAgKSB7XHJcbiAgICAgICAgICAgIGlzQ2hhdE9wZW4gPSB0cnVlO1xyXG4gICAgICAgICAgICBjbGllbnQuZm9jdXMoKTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb25zdCB0aXRsZSA9IGRhdGEudGl0bGUgfHwgXCJNZXNzYWdlIGZyb20gTmV4dCBQb3N0XCI7XHJcbiAgICAgICAgY29uc3QgdXNlckljb24gPSBkYXRhLnVzZXJJY29uO1xyXG4gICAgICAgIGNvbnN0IHR5cGUgPSBkYXRhLnR5cGUgfHwgXCJtZXNzYWdlXCI7XHJcbiAgICAgICAgY29uc3Qgbm90aWZpY2F0aW9uVGFnID0gYGNoYXQtJHtkYXRhLmNoYXRJZH0tJHtkYXRhLmJvZHl9YDtcclxuXHJcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHtcclxuICAgICAgICAgIGJvZHk6IGRhdGEuYm9keSB8fCBcIkNsaWNrIHRvIG9wZW4gY2hhdFwiLFxyXG4gICAgICAgICAgaWNvbjogdXNlckljb24sXHJcbiAgICAgICAgICBiYWRnZTogXCIvYXNzZXRzL2VtYWlsLnBuZ1wiLFxyXG4gICAgICAgICAgc291bmQ6IFwiL2Fzc2V0cy9ub3RpZi5tcDNcIixcclxuICAgICAgICAgIHZpYnJhdGU6IFtcclxuICAgICAgICAgICAgNTAwLCAxMTAsIDUwMCwgMTEwLCA0NTAsIDExMCwgMjAwLCAxMTAsIDE3MCwgNDAsIDQ1MCwgMTEwLCAyMDAsIDExMCxcclxuICAgICAgICAgICAgMTcwLCA0MCwgNTAwLFxyXG4gICAgICAgICAgXSxcclxuICAgICAgICAgIHRhZzogbm90aWZpY2F0aW9uVGFnLFxyXG4gICAgICAgICAgcmVub3RpZnk6IGZhbHNlLFxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIGlmICh0eXBlID09PSBcImNhbGxcIikge1xyXG4gICAgICAgICAgb3B0aW9ucy5hY3Rpb25zID0gW1xyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgYWN0aW9uOiBcImFjY2VwdFwiLFxyXG4gICAgICAgICAgICAgIHR5cGU6IFwiYnV0dG9uXCIsXHJcbiAgICAgICAgICAgICAgdGl0bGU6IFwiQWNjZXB0IENhbGxcIixcclxuICAgICAgICAgICAgICBpY29uOiBcIi9hc3NldHMvaWNvbnMvY2FsbHIucG5nXCIsXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICBhY3Rpb246IFwicmVqZWN0XCIsXHJcbiAgICAgICAgICAgICAgdHlwZTogXCJidXR0b25cIixcclxuICAgICAgICAgICAgICB0aXRsZTogXCJSZWplY3QgQ2FsbFwiLFxyXG4gICAgICAgICAgICAgIGljb246IFwiL2Fzc2V0cy9pY29ucy9jYWxsLnBuZ1wiLFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgXTtcclxuXHJcbiAgICAgICAgICAvLyDQntGC0L/RgNCw0LLQu9GP0LXQvCDRgdC+0L7QsdGJ0LXQvdC40LUg0YfQtdGA0LXQtyBCcm9hZGNhc3RDaGFubmVsXHJcbiAgICAgICAgICBjaGFubmVsLnBvc3RNZXNzYWdlKHtcclxuICAgICAgICAgICAgdHlwZTogXCJJTkNPTUlOR19DQUxMXCIsXHJcbiAgICAgICAgICAgIGNoYXRJZDogZGF0YS5jaGF0SWQsXHJcbiAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICByZXR1cm4gc2VsZi5yZWdpc3RyYXRpb24uc2hvd05vdGlmaWNhdGlvbih0aXRsZSwgb3B0aW9ucyk7XHJcbiAgICAgICAgfSBlbHNlIGlmICghaXNDaGF0T3Blbikge1xyXG4gICAgICAgICAgcmV0dXJuIHNlbGYucmVnaXN0cmF0aW9uXHJcbiAgICAgICAgICAgIC5nZXROb3RpZmljYXRpb25zKHsgdGFnOiBub3RpZmljYXRpb25UYWcgfSlcclxuICAgICAgICAgICAgLnRoZW4oKGV4aXN0aW5nTm90aWZpY2F0aW9ucykgPT4ge1xyXG4gICAgICAgICAgICAgIGlmIChleGlzdGluZ05vdGlmaWNhdGlvbnMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5yZWdpc3RyYXRpb24uc2hvd05vdGlmaWNhdGlvbih0aXRsZSwgb3B0aW9ucyk7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgIH0pXHJcbiAgKTtcclxufSk7XHJcblxyXG5zZWxmLmFkZEV2ZW50TGlzdGVuZXIoXCJub3RpZmljYXRpb25jbGlja1wiLCBmdW5jdGlvbiAoZXZlbnQpIHtcclxuICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gIGV2ZW50Lm5vdGlmaWNhdGlvbi5jbG9zZSgpO1xyXG5cclxuICBldmVudC53YWl0VW50aWwoXHJcbiAgICBjYWNoZXNcclxuICAgICAgLm9wZW4oXCJjaGF0LWRhdGFcIilcclxuICAgICAgLnRoZW4oKGNhY2hlKSA9PiBjYWNoZS5tYXRjaChcImN1cnJlbnQtY2hhdC1kYXRhXCIpKVxyXG4gICAgICAudGhlbigocmVzcG9uc2UpID0+IHtcclxuICAgICAgICBpZiAocmVzcG9uc2UpIHtcclxuICAgICAgICAgIHJldHVybiByZXNwb25zZS5qc29uKCkudGhlbigoZGF0YSkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCB7IGNoYXRJZCwgdHlwZSB9ID0gZGF0YTtcclxuXHJcbiAgICAgICAgICAgIHNlbGYuY2xpZW50c1xyXG4gICAgICAgICAgICAgIC5tYXRjaEFsbCh7IHR5cGU6IFwid2luZG93XCIsIGluY2x1ZGVVbmNvbnRyb2xsZWQ6IHRydWUgfSlcclxuICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoY2xpZW50cykge1xyXG4gICAgICAgICAgICAgICAgbGV0IGNsaWVudCA9IGNsaWVudHMuZmluZChcclxuICAgICAgICAgICAgICAgICAgKGMpID0+XHJcbiAgICAgICAgICAgICAgICAgICAgYy51cmwuc3RhcnRzV2l0aChwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19CQVNFX1VSTCkgJiZcclxuICAgICAgICAgICAgICAgICAgICBcIm5hdmlnYXRlXCIgaW4gY1xyXG4gICAgICAgICAgICAgICAgKTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAodHlwZSA9PT0gXCJjYWxsXCIpIHtcclxuICAgICAgICAgICAgICAgICAgbGV0IGNoYXRVcmwgPSBgJHtwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19CQVNFX1VSTH0vY2hhdC8ke2NoYXRJZH0/c291cmNlPXB1c2hgO1xyXG5cclxuICAgICAgICAgICAgICAgICAgaWYgKGV2ZW50LmFjdGlvbiA9PT0gXCJyZWplY3RcIiB8fCBldmVudC5hY3Rpb24gPT09IFwiYWNjZXB0XCIpIHtcclxuICAgICAgICAgICAgICAgICAgICBjaGF0VXJsICs9IGAmdHlwZT0ke2V2ZW50LmFjdGlvbn1gO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyDQntGC0L/RgNCw0LLQu9GP0LXQvCDRgdC+0L7QsdGJ0LXQvdC40LUg0YfQtdGA0LXQtyBCcm9hZGNhc3RDaGFubmVsXHJcbiAgICAgICAgICAgICAgICAgICAgY2hhbm5lbC5wb3N0TWVzc2FnZSh7XHJcbiAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcIkNBTExfRU5ERURcIixcclxuICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbjogZXZlbnQuYWN0aW9uLFxyXG4gICAgICAgICAgICAgICAgICAgICAgY2hhdElkOiBjaGF0SWQsXHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgIGlmIChldmVudC5hY3Rpb24gPT09IFwicmVqZWN0XCIpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgIGlmIChjbGllbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2xpZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAubmF2aWdhdGUoY2hhdFVybClcclxuICAgICAgICAgICAgICAgICAgICAgIC50aGVuKChjbGllbnQpID0+IGNsaWVudC5mb2N1cygpKTtcclxuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2xpZW50cy5vcGVuV2luZG93KGNoYXRVcmwpO1xyXG4gICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICBjb25zdCBjaGF0VXJsID0gY2hhdElkXHJcbiAgICAgICAgICAgICAgICAgICAgPyBgJHtwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19CQVNFX1VSTH0vY2hhdC8ke2NoYXRJZH1gXHJcbiAgICAgICAgICAgICAgICAgICAgOiBgJHtwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19CQVNFX1VSTH0vY2hhdGA7XHJcbiAgICAgICAgICAgICAgICAgIHJldHVybiBjbGllbnRzLm9wZW5XaW5kb3coY2hhdFVybCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgY2FjaGVzLmRlbGV0ZShcImFjdGlvbi1kYXRhXCIpO1xyXG4gICAgICAgICAgY2FjaGVzLmRlbGV0ZShcImNoYXQtZGF0YVwiKTtcclxuICAgICAgICAgIHJldHVybiBjbGllbnRzLm9wZW5XaW5kb3coYCR7cHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfQkFTRV9VUkx9L2NoYXRgKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0pXHJcbiAgKTtcclxufSk7XHJcblxyXG4vLyDQlNC+0LHQsNCy0LvRj9C10Lwg0L7QsdGA0LDQsdC+0YLRh9C40Log0YHQvtC+0LHRidC10L3QuNC5INC+0YIg0L7RgdC90L7QstC90L7Qs9C+INC/0L7RgtC+0LrQsCAo0LXRgdC70Lgg0L/QvtC90LDQtNC+0LHQuNGC0YHRjylcclxuc2VsZi5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCAoZXZlbnQpID0+IHtcclxuICBjb25zb2xlLmxvZyhcIlNXIHJlY2VpdmVkIG1lc3NhZ2U6XCIsIGV2ZW50LmRhdGEpO1xyXG4gIC8vINCX0LTQtdGB0Ywg0LzQvtC20L3QviDQvtCx0YDQsNCx0LDRgtGL0LLQsNGC0Ywg0YHQvtC+0LHRidC10L3QuNGPINC+0YIg0L7RgdC90L7QstC90L7Qs9C+INC/0L7RgtC+0LrQsCwg0LXRgdC70Lgg0Y3RgtC+INC90LXQvtCx0YXQvtC00LjQvNC+XHJcbn0pO1xyXG4iXSwibmFtZXMiOlsiY2hhbm5lbCIsIkJyb2FkY2FzdENoYW5uZWwiLCJDQUNIRV9OQU1FIiwiSUNPTlNfVE9fQ0FDSEUiLCJzZWxmIiwiYWRkRXZlbnRMaXN0ZW5lciIsImV2ZW50Iiwid2FpdFVudGlsIiwiY2FjaGVzIiwib3BlbiIsInRoZW4iLCJjYWNoZSIsImFkZEFsbCIsImluY2x1ZGVzIiwicmVxdWVzdCIsInVybCIsInJlc3BvbmRXaXRoIiwibWF0Y2giLCJyZXNwb25zZSIsImZldGNoIiwic3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uIiwibm90aWZpY2F0aW9uIiwiZGF0YSIsImNvbnNvbGUiLCJsb2ciLCJ0eXBlIiwicG9zdE1lc3NhZ2UiLCJhY3Rpb24iLCJjaGF0SWQiLCJjbGllbnRzIiwibWF0Y2hBbGwiLCJmb3JFYWNoIiwiY2xpZW50IiwicHV0IiwiUmVzcG9uc2UiLCJKU09OIiwic3RyaW5naWZ5Iiwic3RhdHVzIiwidGltZXN0YW1wIiwiRGF0ZSIsIm5vdyIsInByZXZlbnREZWZhdWx0IiwianNvbiIsImNoYXREYXRhUmVzcG9uc2UiLCJCbG9iIiwiaW5jbHVkZVVuY29udHJvbGxlZCIsImlzQ2hhdE9wZW4iLCJjaGF0VXJsIiwicHJvY2VzcyIsImVudiIsIk5FWFRfUFVCTElDX0JBU0VfVVJMIiwiZm9jdXMiLCJ0aXRsZSIsInVzZXJJY29uIiwibm90aWZpY2F0aW9uVGFnIiwiYm9keSIsIm9wdGlvbnMiLCJpY29uIiwiYmFkZ2UiLCJzb3VuZCIsInZpYnJhdGUiLCJ0YWciLCJyZW5vdGlmeSIsImFjdGlvbnMiLCJyZWdpc3RyYXRpb24iLCJzaG93Tm90aWZpY2F0aW9uIiwiZ2V0Tm90aWZpY2F0aW9ucyIsImV4aXN0aW5nTm90aWZpY2F0aW9ucyIsImxlbmd0aCIsImNsb3NlIiwiZmluZCIsImMiLCJzdGFydHNXaXRoIiwibmF2aWdhdGUiLCJvcGVuV2luZG93IiwiZGVsZXRlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./worker/index.js\n"));

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			if (cachedModule.error !== undefined) throw cachedModule.error;
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		var threw = true;
/******/ 		try {
/******/ 			__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 			threw = false;
/******/ 		} finally {
/******/ 			if(threw) delete __webpack_module_cache__[moduleId];
/******/ 		}
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/trusted types policy */
/******/ 	!function() {
/******/ 		var policy;
/******/ 		__webpack_require__.tt = function() {
/******/ 			// Create Trusted Type policy if Trusted Types are available and the policy doesn't exist yet.
/******/ 			if (policy === undefined) {
/******/ 				policy = {
/******/ 					createScript: function(script) { return script; }
/******/ 				};
/******/ 				if (typeof trustedTypes !== "undefined" && trustedTypes.createPolicy) {
/******/ 					policy = trustedTypes.createPolicy("nextjs#bundler", policy);
/******/ 				}
/******/ 			}
/******/ 			return policy;
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/trusted types script */
/******/ 	!function() {
/******/ 		__webpack_require__.ts = function(script) { return __webpack_require__.tt().createScript(script); };
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/react refresh */
/******/ 	!function() {
/******/ 		if (__webpack_require__.i) {
/******/ 		__webpack_require__.i.push(function(options) {
/******/ 			var originalFactory = options.factory;
/******/ 			options.factory = function(moduleObject, moduleExports, webpackRequire) {
/******/ 				var hasRefresh = typeof self !== "undefined" && !!self.$RefreshInterceptModuleExecution$;
/******/ 				var cleanup = hasRefresh ? self.$RefreshInterceptModuleExecution$(moduleObject.id) : function() {};
/******/ 				try {
/******/ 					originalFactory.call(this, moduleObject, moduleExports, webpackRequire);
/******/ 				} finally {
/******/ 					cleanup();
/******/ 				}
/******/ 			}
/******/ 		})
/******/ 		}
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/compat */
/******/ 	
/******/ 	
/******/ 	// noop fns to prevent runtime errors during initialization
/******/ 	if (typeof self !== "undefined") {
/******/ 		self.$RefreshReg$ = function () {};
/******/ 		self.$RefreshSig$ = function () {
/******/ 			return function (type) {
/******/ 				return type;
/******/ 			};
/******/ 		};
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval-source-map devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./worker/index.js");
/******/ 	
/******/ })()
;